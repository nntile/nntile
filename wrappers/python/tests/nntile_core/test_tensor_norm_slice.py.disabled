# @copyright (c) 2022-present Skolkovo Institute of Science and Technology
#                              (Skoltech), Russia. All rights reserved.
#                2023-present Artificial Intelligence Research Institute
#                              (AIRI), Russia. All rights reserved.
#
# NNTile is software framework for fast training of big neural networks on
# distributed-memory heterogeneous systems based on StarPU runtime system.
#
# @file wrappers/python/tests/nntile_core/test_tensor_norm_slice.py
# Test for tensor::norm_slice<T> Python wrapper
#
# @version 1.1.0

from dataclasses import dataclass

import numpy as np
import pytest

import nntile
import nntile.utils.constructors as nntc

# Define mapping between numpy and nntile types
Tensor = {
    np.float32: nntile.tensor.Tensor_fp32,
    np.float64: nntile.tensor.Tensor_fp64
}

# Define mapping between tested function and numpy type
norm_slice = {
    np.float32: nntile.nntile_core.tensor.norm_slice_async_fp32,
    np.float64: nntile.nntile_core.tensor.norm_slice_async_fp64
}

norm_slice_inplace = {
    np.float32: nntile.nntile_core.tensor.norm_slice_inplace_async_fp32,
    np.float64: nntile.nntile_core.tensor.norm_slice_inplace_async_fp64
}


@dataclass
class NormSliceTestParams:
    shape: list[int]
    shape_tile: list[int]
    axis: int


single_tile = NormSliceTestParams(
    shape=[2, 2, 2, 2],
    shape_tile=[2, 2, 2, 2],
    axis=0,
)

multiple_tiles = NormSliceTestParams(
    shape=[2, 2, 2, 2],
    shape_tile=[1, 1, 1, 1],
    axis=0,
)


def get_ref_value(alpha, src1, beta, src2, axis):
    # For norm_slice, compute the expected result based on kernel behavior
    # The kernel computes: dst[i,j] = hypot(beta*src2[i,j], alpha*norm(src1[i,:,j]))

    if axis == 1:
        # For axis=1 on 4D tensor [a,b,c,d]:
        # - Compute norm along axis 1 (b dimension)
        # - Result shape is [a,c,d] (same as src2)

        a, b, c, d = src1.shape
        result = np.zeros((a, c, d), dtype=src1.dtype)

        # For each position in the result tensor
        for i in range(a):  # a dimension
            for j in range(c):  # c dimension
                for k in range(d):  # d dimension
                    # Compute norm of fiber src1[i, :, j, k] along axis 1
                    fiber = src1[i, :, j, k]
                    fiber_norm = np.linalg.norm(fiber)

                    # Combine with src2 using hypot
                    result[i, j, k] = np.hypot(alpha * fiber_norm, beta * src2[i, j, k])
    else:
        # For other axes, implement accordingly
        raise NotImplementedError("Only axis=1 implemented in reference")

    return result


@pytest.mark.skip(reason="Test disabled - reference implementation needs refinement for axis=0")
@pytest.mark.parametrize('dtype', [np.float32, np.float64])
@pytest.mark.parametrize('params', [
    pytest.param(single_tile, id='single_tile'),
    pytest.param(multiple_tiles, id='multiple_tiles'),
])
def test_norm_slice_async(context, dtype, params):
    pass
